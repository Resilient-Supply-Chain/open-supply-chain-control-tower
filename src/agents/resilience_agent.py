from __future__ import annotations

from pathlib import Path
from typing import List

from pydantic import BaseModel, Field
from pydantic_ai import Agent

from src.models.report import AffectedSME, ResilienceReport
from src.models.signal import AlertPriority, RiskSignal
from src.tools.geo_utils import find_smes_by_location


class AgentConfig(BaseModel):
    """Configuration for the resilience agent.

    In real deployments, the model configuration (e.g., Claude 3.5 Sonnet) would
    be injected here via environment variables or higher-level orchestration.
    
    The model parameter accepts a model string identifier (e.g., 'anthropic:claude-3-5-sonnet-latest')
    following the PydanticAI model specification format.
    """

    model: str = Field(
        default="anthropic:claude-3-5-sonnet-latest",
        description="PydanticAI model identifier (e.g., 'anthropic:claude-3-5-sonnet-latest').",
    )
    sme_registry_path: Path = Field(
        ..., description="Filesystem path to the local SME registry JSON file.",
    )


def _derive_priority(risk_score: float) -> AlertPriority:
    if risk_score > 0.9:
        return "HIGH"
    if risk_score > 0.6:
        return "MEDIUM"
    return "LOW"


def _render_markdown_alert(
    *, priority: AlertPriority, signal: RiskSignal, affected_smes: List[AffectedSME]
) -> str:
    header = f"## Supply Chain Alert ({priority})"
    summary = (
        f"- **Risk score**: {signal.risk_score}\n"
        f"- **Location**: {signal.location}\n"
        f"- **Primary driver**: {signal.primary_driver}\n"
        f"- **Estimated impact**: {signal.estimated_impact}\n"
    )

    if affected_smes:
        sme_lines = ["- **Potentially affected SMEs:**"]
        for sme in affected_smes:
            sme_lines.append(
                f"  - {sme.name} (`{sme.sme_id}`) â€” {sme.sector}, {sme.county}"
            )
        sme_block = "\n".join(sme_lines)
    else:
        sme_block = "- **Potentially affected SMEs:** None found in current registry."

    guidance = (
        "\n\n---\n\n"
        "_This alert is generated by the AI control tower prototype aligned with "
        "S.257 and E.O. 14123 to support U.S. SME supply-chain resilience._"
    )

    return "\n\n".join([header, summary, sme_block]) + guidance


def process_risk_signal(
    *, signal: RiskSignal, sme_registry_path: Path
) -> ResilienceReport:
    """Process a RiskSignal and generate a ResilienceReport.

    This is the core deterministic processing logic used by both the standalone
    function (for v0.0.1) and the PydanticAI agent (for future RAG-enhanced versions).
    """

    # Tool: find affected SMEs based on location.
    affected_smes = find_smes_by_location(
        registry_path=sme_registry_path, location=signal.location
    )

    priority = _derive_priority(signal.risk_score)
    markdown_alert = _render_markdown_alert(
        priority=priority, signal=signal, affected_smes=affected_smes
    )

    report = ResilienceReport(
        priority=priority,
        risk_signal=signal,
        affected_smes=affected_smes,
        markdown_alert=markdown_alert,
    )
    return report


def build_resilience_agent(config: AgentConfig) -> Agent[RiskSignal, ResilienceReport]:
    """Construct a PydanticAI agent that maps RiskSignal -> ResilienceReport.

    The agent is intentionally simple in v0.0.1 and primarily orchestrates
    deterministic logic plus a Markdown narrative. In later versions, the
    `model` provided in `AgentConfig` can be used to co-generate the narrative
    with deeper policy and sector grounding via RAG.

    Note: For v0.0.1, the agent structure is prepared but the actual processing
    uses `process_risk_signal()` directly. Future versions will leverage the
    LLM model for enhanced narrative generation and RAG-based policy grounding.
    """

    # In v0.0.1 we primarily use PydanticAI for type-safe orchestration; the
    # `model` parameter accepts a model string (e.g., 'anthropic:claude-3-5-sonnet-latest')
    # which enables easy extension to Claude 3.5 Sonnet or other providers.
    # The agent structure is set up for future RAG integration where the LLM
    # will enhance the markdown generation with policy context.
    return Agent[RiskSignal, ResilienceReport](
        model=config.model,
        system_prompt=(
            "You are an AI supply-chain resilience analyst. Given a typed "
            "RiskSignal, generate structured, concise, and policy-aligned "
            "resilience alerts for U.S. SMEs, consistent with S.257 and "
            "E.O. 14123. Prioritize clarity, auditability, and conservative "
            "risk communication."
        ),
        result_type=ResilienceReport,
    )


__all__ = ["AgentConfig", "build_resilience_agent", "process_risk_signal"]

