from __future__ import annotations

from pathlib import Path
from typing import List

from pydantic import BaseModel, Field
from pydantic_ai import Agent, Model

from src.models.report import AffectedSME, ResilienceReport
from src.models.signal import AlertPriority, RiskSignal
from src.tools.geo_utils import find_smes_by_location


class AgentConfig(BaseModel):
    """Configuration for the resilience agent.

    In real deployments, the model configuration (e.g., Claude 3.5 Sonnet) would
    be injected here via environment variables or higher-level orchestration.
    """

    model: Model = Field(..., description="Underlying PydanticAI model backend.")
    sme_registry_path: Path = Field(
        ..., description="Filesystem path to the local SME registry JSON file.",
    )


def _derive_priority(risk_score: float) -> AlertPriority:
    if risk_score > 0.9:
        return "HIGH"
    if risk_score > 0.6:
        return "MEDIUM"
    return "LOW"


def _render_markdown_alert(
    *, priority: AlertPriority, signal: RiskSignal, affected_smes: List[AffectedSME]
) -> str:
    header = f"## Supply Chain Alert ({priority})"
    summary = (
        f"- **Risk score**: {signal.risk_score}\n"
        f"- **Location**: {signal.location}\n"
        f"- **Primary driver**: {signal.primary_driver}\n"
        f"- **Estimated impact**: {signal.estimated_impact}\n"
    )

    if affected_smes:
        sme_lines = ["- **Potentially affected SMEs:**"]
        for sme in affected_smes:
            sme_lines.append(
                f"  - {sme.name} (`{sme.sme_id}`) â€” {sme.sector}, {sme.county}"
            )
        sme_block = "\n".join(sme_lines)
    else:
        sme_block = "- **Potentially affected SMEs:** None found in current registry."

    guidance = (
        "\n\n---\n\n"
        "_This alert is generated by the AI control tower prototype aligned with "
        "S.257 and E.O. 14123 to support U.S. SME supply-chain resilience._"
    )

    return "\n\n".join([header, summary, sme_block]) + guidance


def build_resilience_agent(config: AgentConfig) -> Agent[RiskSignal, ResilienceReport]:
    """Construct a PydanticAI agent that maps RiskSignal -> ResilienceReport.

    The agent is intentionally simple in v0.0.1 and primarily orchestrates
    deterministic logic plus a Markdown narrative. In later versions, the
    `model` provided in `AgentConfig` can be used to co-generate the narrative
    with deeper policy and sector grounding via RAG.
    """

    async def _handler(signal: RiskSignal) -> ResilienceReport:  # type: ignore[override]
        # Tool: find affected SMEs based on location.
        affected_smes = find_smes_by_location(
            registry_path=config.sme_registry_path, location=signal.location
        )

        priority = _derive_priority(signal.risk_score)
        markdown_alert = _render_markdown_alert(
            priority=priority, signal=signal, affected_smes=affected_smes
        )

        report = ResilienceReport(
            priority=priority,
            risk_signal=signal,
            affected_smes=affected_smes,
            markdown_alert=markdown_alert,
        )
        return report

    # In v0.0.1 we primarily use PydanticAI for type-safe orchestration; the
    # `model` hook enables easy extension to Claude 3.5 Sonnet.
    return Agent[RiskSignal, ResilienceReport](
        model=config.model,
        system_prompt=(
            "You are an AI supply-chain resilience analyst. Given a typed "
            "RiskSignal, generate structured, concise, and policy-aligned "
            "resilience alerts for U.S. SMEs, consistent with S.257 and "
            "E.O. 14123. Prioritize clarity, auditability, and conservative "
            "risk communication."
        ),
        handler=_handler,
    )


__all__ = ["AgentConfig", "build_resilience_agent"]

