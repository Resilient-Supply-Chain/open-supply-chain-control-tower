from __future__ import annotations

from pathlib import Path
from typing import List, Optional

from pydantic import BaseModel, Field
from pydantic_ai import Agent

from src.models.report import AffectedSME, ResilienceReport
from src.models.signal import AlertPriority, RiskSignal
from src.tools.geo_engine import get_smes_in_radius


class AgentConfig(BaseModel):
    """Configuration for the resilience agent.

    In real deployments, the model configuration (e.g., Claude 3.5 Sonnet) would
    be injected here via environment variables or higher-level orchestration.
    
    The model parameter accepts a model string identifier (e.g., 'anthropic:claude-3-5-sonnet-latest')
    following the PydanticAI model specification format.
    """

    model: str = Field(
        default="anthropic:claude-3-5-sonnet-latest",
        description="PydanticAI model identifier (e.g., 'anthropic:claude-3-5-sonnet-latest').",
    )
    sme_registry_path: Path = Field(
        ..., description="Filesystem path to the local SME registry JSON file.",
    )


def _derive_priority(risk_score: float) -> AlertPriority:
    if risk_score > 0.9:
        return "HIGH"
    if risk_score > 0.6:
        return "MEDIUM"
    return "LOW"


def _render_markdown_alert(
    *,
    priority: AlertPriority,
    signal: RiskSignal,
    affected_smes: List[AffectedSME],
    policy_context: Optional[str] = None,
    geo_context: Optional[str] = None,
    logistics_context: Optional[str] = None,
) -> str:
    priority_icon = {"HIGH": "ðŸš¨", "MEDIUM": "âš ï¸", "LOW": "â„¹ï¸"}.get(priority, "â„¹ï¸")
    header = f"## {priority_icon} Supply Chain Alert ({priority})"
    summary = (
        f"- ðŸ§­ **Risk score**: {signal.risk_score}\n"
        f"- ðŸ“ **Location**: {signal.location}\n"
        f"- ðŸ§ª **Primary driver**: {signal.primary_driver}\n"
        f"- ðŸ’° **Estimated impact**: {signal.estimated_impact}\n"
    )

    if affected_smes:
        sme_lines = ["- ðŸ¢ **Potentially affected SMEs:**"]
        for sme in affected_smes:
            distance_note = (
                f" (~{sme.distance_km:.1f} km from epicenter)"
                if sme.distance_km is not None
                else ""
            )
            sme_lines.append(
                f"  - ðŸ”¹ {sme.name} (`{sme.sme_id}`) â€” {sme.sector}, {sme.county}{distance_note}"
            )
        sme_block = "\n".join(sme_lines)
    else:
        sme_block = "- ðŸ¢ **Potentially affected SMEs:** None found in current registry."

    geo_block = f"\n\n{geo_context.strip()}" if geo_context else ""
    context_block = f"\n\n{policy_context.strip()}" if policy_context else ""
    logistics_block = f"\n\n{logistics_context.strip()}" if logistics_context else ""
    guidance = (
        "\n\n---\n\n"
        "ðŸ“Œ _This alert is generated by the AI control tower prototype aligned with "
        "S.257 and E.O. 14123 to support U.S. SME supply-chain resilience._"
    )

    return (
        "\n\n".join([header, summary, sme_block])
        + geo_block
        + logistics_block
        + context_block
        + guidance
    )


def process_risk_signal(
    *,
    signal: RiskSignal,
    sme_registry_path: Path,
    policy_context: Optional[str] = None,
    logistics_context: Optional[str] = None,
) -> ResilienceReport:
    """Process a RiskSignal and generate a ResilienceReport.

    This is the core deterministic processing logic used by both the standalone
    function (for v0.0.1) and the PydanticAI agent (for future RAG-enhanced versions).
    """

    # Tool: find affected SMEs based on location.
    affected_smes, _ = get_smes_in_radius(
        registry_path=sme_registry_path,
        center=(signal.geo_center.lat, signal.geo_center.lon),
        radius_km=signal.geo_center.impact_radius_km,
    )

    priority = _derive_priority(signal.risk_score)
    geo_context = (
        "\n".join(
            [
                "### ðŸ—ºï¸ Geospatial Risk Visualization",
                (
                    f"SMEs within **{signal.geo_center.impact_radius_km:.1f} km** "
                    f"of the soil saturation epicenter at "
                    f"({signal.geo_center.lat:.4f}, {signal.geo_center.lon:.4f}) "
                    "are prioritized for monitoring."
                ),
                "An interactive map is available at `outputs/risk_map.html`.",
            ]
        )
        if signal.geo_center
        else ""
    )
    markdown_alert = _render_markdown_alert(
        priority=priority,
        signal=signal,
        affected_smes=affected_smes,
        policy_context=policy_context,
        geo_context=geo_context,
        logistics_context=logistics_context,
    )

    report = ResilienceReport(
        priority=priority,
        risk_signal=signal,
        affected_smes=affected_smes,
        markdown_alert=markdown_alert,
    )
    return report


def build_resilience_agent(config: AgentConfig) -> Agent[RiskSignal, ResilienceReport]:
    """Construct a PydanticAI agent that maps RiskSignal -> ResilienceReport.

    The agent is intentionally simple in v0.0.1 and primarily orchestrates
    deterministic logic plus a Markdown narrative. In later versions, the
    `model` provided in `AgentConfig` can be used to co-generate the narrative
    with deeper policy and sector grounding via RAG.

    Note: For v0.0.1, the agent structure is prepared but the actual processing
    uses `process_risk_signal()` directly. Future versions will leverage the
    LLM model for enhanced narrative generation and RAG-based policy grounding.
    """

    # In v0.0.1 we primarily use PydanticAI for type-safe orchestration; the
    # `model` parameter accepts a model string (e.g., 'anthropic:claude-3-5-sonnet-latest')
    # which enables easy extension to Claude 3.5 Sonnet or other providers.
    # The agent structure is set up for future RAG integration where the LLM
    # will enhance the markdown generation with policy context.
    return Agent[RiskSignal, ResilienceReport](
        model=config.model,
        system_prompt=(
            "You are an AI supply-chain resilience analyst. Given a typed "
            "RiskSignal, generate structured, concise, and policy-aligned "
            "resilience alerts for U.S. SMEs, consistent with S.257 and "
            "E.O. 14123. Prioritize clarity, auditability, and conservative "
            "risk communication.\n\n"
            "When presenting the 'Relevant S.257 Policy Context', do NOT "
            "copy raw snippets. Instead:\n"
            "- Data cleaning: strictly strip line numbers, repetitive headers "
            "(e.g., 'â€  S 257 ES'), and page markers.\n"
            "- Word reconstruction: repair words broken by PDF line breaks "
            "(e.g., 'crit-ical' -> 'critical').\n"
            "- Semantic summarization: synthesize 2-3 professional, bulleted "
            "policy insights that explain how the retrieved S.257 sections "
            "apply to the current risk signal (e.g., Monterey soil saturation).\n"
            "- Formal citations: end each synthesized point with a standardized "
            "citation such as (Source: S.257, Sec. 28).\n"
            "- Markdown structure: use professional headers (e.g., "
            "'### Policy-Driven Risk Mitigation') and executive-level tone "
            "appropriate for a government-aligned control tower prototype.\n"
            "The policy context should read like a professional legal brief "
            "providing actionable intelligence, not an OCR dump."
        ),
        result_type=ResilienceReport,
    )


__all__ = ["AgentConfig", "build_resilience_agent", "process_risk_signal"]

